templateR:::source_all()
templateR:::args2vars(construct_runners)
#### Check args ####
construct_runners_check_args(os = os,
bioc = bioc,
r = r,
cont = cont)
cont <- construct_runners_check_cont(cont = cont,
versions_explicit = versions_explicit)
#### Set runners
runners <- lapply(os, function(o){
if(isTRUE(versions_explicit)){
info <- bioc_r_versions(bioc_version = bioc[[o]])
} else {
info <- list(bioc=bioc[[o]],
r=r[[o]])
}
list(os = o,
bioc=info$bioc,
r=info$r,
cont=cont[[o]],
rspm=rspm[[o]]
)
})
runners
cont
cont = stats::setNames(
list(paste0("bioconductor/bioconductor_docker:",
bioc[[1]]),
NULL,
NULL),
os
)
cont
lapply(stats::setNames(names(cont),
names(cont)
),function(n){
co <- cont[[n]]
if(is.null(co)) return(NULL)
splt <- strsplit(co,":")[[1]]
bioc_version <- rev(splt)[[1]]
if(isTRUE(versions_explicit)){
if(grepl(":",co)){
info <- bioc_r_versions(bioc_version = bioc_version)
return(
paste0(splt[[1]],":RELEASE_",gsub("[.]","_",info$bioc))
)
} else {
return(co)
}
} else {
if(tolower(bioc_version)=="release"){
bioc_version <- "latest"
}
return(bioc_version)
}
})
names(cont)
n
co <- cont[[n]]
co
if(is.null(co)){
return(NULL)
} else if(!grepl(":",co)) {
return(co)
}
splt <- strsplit(co,":")[[1]]
bioc_version <- rev(splt)[[1]]
splt
bioc_version
isTRUE(versions_explicit)
if(grepl(":",co)){
info <- bioc_r_versions(bioc_version = bioc_version)
return(
paste0(splt[[1]],":RELEASE_",gsub("[.]","_",info$bioc))
)
} else {
return(co)
}
grepl(":",co)
info <- bioc_r_versions(bioc_version = bioc_version)
info
paste0(splt[[1]],":RELEASE_",gsub("[.]","_",info$bioc))
co
lapply(stats::setNames(names(cont),
names(cont)
),function(n){
co <- cont[[n]]
if(is.null(co)){
return(NULL)
} else if(!grepl(":",co)) {
return(co)
}
splt <- strsplit(co,":")[[1]]
bioc_version <- rev(splt)[[1]]
if(isTRUE(versions_explicit)){
if(grepl(":",co)){
info <- bioc_r_versions(bioc_version = bioc_version)
return(
paste0(splt[[1]],":RELEASE_",gsub("[.]","_",info$bioc))
)
} else {
return(co)
}
} else if(tolower(bioc_version)=="release"){
bioc_version <- "latest"
}
return(bioc_version)
})
cont
cont[[n]]
co <- cont[[n]]
if(is.null(co)){
return(NULL)
} else if(!grepl(":",co)) {
return(co)
}
splt <- strsplit(co,":")[[1]]
bioc_version <- rev(splt)[[1]]
if(isTRUE(versions_explicit)){
if(grepl(":",co)){
info <- bioc_r_versions(bioc_version = bioc_version)
return(
paste0(splt[[1]],":RELEASE_",gsub("[.]","_",info$bioc))
)
} else {
return(co)
}
} else if(tolower(bioc_version)=="release"){
bioc_version <- "latest"
}
gsub(":release",":latest",co)
lapply(stats::setNames(names(cont),
names(cont)
),function(n){
co <- cont[[n]]
if(is.null(co)){
return(NULL)
} else if(!grepl(":",co)) {
return(co)
}
splt <- strsplit(co,":")[[1]]
bioc_version <- rev(splt)[[1]]
if(isTRUE(versions_explicit)){
if(grepl(":",co)){
info <- bioc_r_versions(bioc_version = bioc_version)
return(
paste0(splt[[1]],":RELEASE_",gsub("[.]","_",info$bioc))
)
} else {
return(co)
}
} else if(tolower(bioc_version)=="release"){
co <- gsub(":release",":latest",co)
}
return(co)
})
source("~/Desktop/rworkflows/R/construct_runners_check_cont.R", echo=TRUE)
construct_runners_check_cont(cont = cont,
versions_explicit = versions_explicit)
versions_explicit
versions_explicit=T
construct_runners_check_cont(cont = cont,
versions_explicit = versions_explicit)
devtools::document()
library(rworkflows)
library(rworkflows)
rworkflows::use_badges(add_actions=c('rworkflows','rworkflows_static'),add_cran_release = T)
devtools::document()
?use_badges
badger::badge_codecov()
badger::badge_codecov(branch = NULL)
badger::badge_codecov(O
badger::badge_codecov()
?badger::badge_code_size(
)
badger::badge_code_size()
badger::badge_code_size("master")
badger::badge_codecov()
?pak::pkg_install()
View(options())
View(options
)
View(pak::pkg_install)
View(pak:::pkg_install_do_plan)
pkgdepends
install.packages("pkgdepends")
View(pkgdepends::install_package_plan)
devtools::document()
devtools::document()
library(rworkflows)
use_workflow(name="rworkflows_static")
use_workflow(name="rworkflows_static", force_new = T)
?rcmdcheck::rcmdcheck()
tools::package_native_routine_registration_skeleton(".")
?tools::package_native_routine_registration_skeleton(".")
BiocCheck::BiocCheck()
?BiocCheck::BiocCheck()
devtools::document()
library(rworkflows)
devtools::build_manual("inst")
devtools::build_manual(path = "inst")
library(rworkflows)
citation("rworkflows")
rworkflows::use_badges(add_actions=c('rworkflows','rworkflows_static'), add_cran_release = TRUE, add_cran_checks = TRUE, add_cran_download_month=TRUE, add_cran_download_total=TRUE)
scKirby::source_all()
templateR:::source_all()
templateR:::args2vars(use_badges)
h["hex"] <- get_hex(branch = branch,
hex_height = hex_height,
verbose = verbose)
h <- list()
#### Hex ####
if(isTRUE(add_hex)){
h["hex"] <- get_hex(branch = branch,
hex_height = hex_height,
verbose = verbose)
}
URL <- desc::desc_get_field(key = "URL")
URL
paste(URL,"raw",branch,"inst/hex/hex.png",sep="/")
grep("git",URL,value = TRUE)
grep("git",strsplit(URL,","),value = TRUE)
grep("git",strsplit(URL,",")[[1]],value = TRUE)
source("~/Desktop/rworkflows/R/get_hex.R", echo=TRUE)
get_hex(branch = branch,
hex_height = hex_height,
verbose = verbose)
devtools::document()
library(rworkflows)
templateR:::source_all()
templateR:::args2vars(use_badges)
#### Hex ####
if(isTRUE(add_hex)){
h["hex"] <- get_hex(branch = branch,
hex_height = hex_height,
verbose = verbose)
}
#### GitHub ####
if(isTRUE(add_github_version)){
messager("Adding version.",v=verbose)
h["version"] <- badger::badge_github_version(color = colors$github)
}
h <- list()
#### Hex ####
if(isTRUE(add_hex)){
h["hex"] <- get_hex(branch = branch,
hex_height = hex_height,
verbose = verbose)
}
#### GitHub ####
if(isTRUE(add_github_version)){
messager("Adding version.",v=verbose)
h["version"] <- badger::badge_github_version(color = colors$github)
}
if(!is.null(add_actions) &&
!isFALSE(add_actions) &&
is.character(add_actions)){
messager("Adding actions.",v=verbose)
for(action in add_actions){
h[paste0("actions_",action)] <-
badger::badge_github_actions(action = action)
}
}
if(isTRUE(add_commit)){
messager("Adding commit.",v=verbose)
h["commit"] <- badger::badge_last_commit(branch = branch)
}
#### Other metadata ####
if(isTRUE(add_code_size)){
messager("Adding code size",v=verbose)
h["codesize"] <- badger::badge_code_size()
}
if(isTRUE(add_codecov)){
messager("Adding codecov.",v=verbose)
h["codecov"] <- badger::badge_codecov(branch = branch)
}
if(isTRUE(add_license)){
messager("Adding license.",v=verbose)
h["license"] <-  badger::badge_license(color = colors$default)
}
if(!is.null(add_doi)){
messager("Adding DOI.",v=verbose)
h["doi"] <-  badger::badge_doi(doi = add_doi,
color = colors$default)
}
#### Bioc-specific badges #####
if(isTRUE(add_bioc_release)){
messager("Adding Bioconductor release version.",v=verbose)
h["bioc_release"] <-  badger::badge_bioc_release(color = colors$bioc)
}
if(isTRUE(add_bioc_download_month)){
messager("Adding Bioc downloads: by month",v=verbose)
h["bioc_download_month"] <-  badger::badge_bioc_download(
by = "month",
color = colors$bioc)
}
if(isTRUE(add_bioc_download_total)){
messager("Adding Bioc downloads: by total",v=verbose)
h["bioc_download_total"] <-  badger::badge_bioc_download(
by = "total",
color = colors$bioc)
}
if(isTRUE(add_bioc_download_rank)){
messager("Adding license.",v=verbose)
h["bioc_download_rank"] <-  badger::badge_bioc_download_rank()
}
#### CRAN-specific badges #####
if(isTRUE(add_cran_release)){
messager("Adding CRAN release version.",v=verbose)
h["cran_release"] <- badger::badge_cran_release(color = colors$cran)
}
if(isTRUE(add_cran_checks)){
messager("Adding CRAN checks.",v=verbose)
h["cran_checks"] <- badger::badge_cran_checks()
}
if(isTRUE(add_cran_download_month)){
messager("Adding CRAN downloads: last-month",v=verbose)
h["cran_download_month"] <-  badger::badge_cran_download(
type = "last-month",
color = colors$cran)
}
if(isTRUE(add_cran_download_total)){
messager("Adding CRAN downloads: grand-total",v=verbose)
h["cran_download_total"] <-  badger::badge_cran_download(
type = "grand-total",
color = colors$cran)
}
#### Authors ####
if(isTRUE(add_authors)){
messager("Adding authors.",v=verbose)
h["authors"] <- get_authors(add_html = TRUE)
}
#### Return ####
if(isTRUE(as_list)){
return(h)
} else {
#### Add a break after the first item (usually hex sticker) ####
if(!is.null(h[["hex"]])){
hc <- paste(paste0(h[1],"<br><br>"),
paste(h[-1],collapse=sep),
sep=sep)
} else {
hc <- paste(h,collapse=sep)
}
cat(hc)
return(hc)
}
#' (when \code{add_hex=TRUE}).
#' @returns A named list of selected badges in markdown format.
#'
#' @export
#' @import badger
#' @examples
#' ## Causes issues bc examples can't find the  the DESCRIPTION file.
#'  \dontrun{
#'  rworkflows::use_badges()
#'  }
use_badges <- function(add_hex = TRUE,
add_actions = "rworkflows",
add_doi = NULL,
## GitHub
add_github_version = TRUE,
add_commit = TRUE,
add_code_size = TRUE,
add_codecov = TRUE,
add_license = TRUE,
add_authors = TRUE,
## Bioc-specific
add_bioc_release = FALSE,
add_bioc_download_month = FALSE,
add_bioc_download_total = FALSE,
add_bioc_download_rank = FALSE,
## CRAN-specific
add_cran_release = FALSE,
add_cran_checks = FALSE,
add_cran_download_month = FALSE,
add_cran_download_total = FALSE,
## etc.
branch = "master",
as_list = FALSE,
sep = "\n",
hex_height = 600,
colors = list("github"="black",
"bioc"="green",
"cran"="blue",
"default"="blue"),
verbose = TRUE){
# templateR:::source_all()
# templateR:::args2vars(use_badges)
h <- list()
#### Hex ####
if(isTRUE(add_hex)){
h["hex"] <- get_hex(branch = branch,
hex_height = hex_height,
verbose = verbose)
}
#### GitHub ####
if(isTRUE(add_github_version)){
messager("Adding version.",v=verbose)
h["version"] <- badger::badge_github_version(color = colors$github)
}
if(!is.null(add_actions) &&
!isFALSE(add_actions) &&
is.character(add_actions)){
messager("Adding actions.",v=verbose)
for(action in add_actions){
h[paste0("actions_",action)] <-
badger::badge_github_actions(action = action)
}
}
if(isTRUE(add_commit)){
messager("Adding commit.",v=verbose)
h["commit"] <- badger::badge_last_commit(branch = branch)
}
#### Other metadata ####
if(isTRUE(add_code_size)){
messager("Adding code size",v=verbose)
h["codesize"] <- badger::badge_code_size()
}
if(isTRUE(add_codecov)){
messager("Adding codecov.",v=verbose)
h["codecov"] <- badger::badge_codecov(branch = branch)
}
if(isTRUE(add_license)){
messager("Adding license.",v=verbose)
h["license"] <-  badger::badge_license(color = colors$default)
}
if(!is.null(add_doi)){
messager("Adding DOI.",v=verbose)
h["doi"] <-  badger::badge_doi(doi = add_doi,
color = colors$default)
}
#### Bioc-specific badges #####
if(isTRUE(add_bioc_release)){
messager("Adding Bioconductor release version.",v=verbose)
h["bioc_release"] <-  badger::badge_bioc_release(color = colors$bioc)
}
if(isTRUE(add_bioc_download_month)){
messager("Adding Bioc downloads: by month",v=verbose)
h["bioc_download_month"] <-  badger::badge_bioc_download(
by = "month",
color = colors$bioc)
}
if(isTRUE(add_bioc_download_total)){
messager("Adding Bioc downloads: by total",v=verbose)
h["bioc_download_total"] <-  badger::badge_bioc_download(
by = "total",
color = colors$bioc)
}
if(isTRUE(add_bioc_download_rank)){
messager("Adding license.",v=verbose)
h["bioc_download_rank"] <-  badger::badge_bioc_download_rank()
}
#### CRAN-specific badges #####
if(isTRUE(add_cran_release)){
messager("Adding CRAN release version.",v=verbose)
h["cran_release"] <- badger::badge_cran_release(color = colors$cran)
}
if(isTRUE(add_cran_checks)){
messager("Adding CRAN checks.",v=verbose)
h["cran_checks"] <- badger::badge_cran_checks()
}
if(isTRUE(add_cran_download_month)){
messager("Adding CRAN downloads: last-month",v=verbose)
h["cran_download_month"] <-  badger::badge_cran_download(
type = "last-month",
color = colors$cran)
}
if(isTRUE(add_cran_download_total)){
messager("Adding CRAN downloads: grand-total",v=verbose)
h["cran_download_total"] <-  badger::badge_cran_download(
type = "grand-total",
color = colors$cran)
}
#### Authors ####
if(isTRUE(add_authors)){
messager("Adding authors.",v=verbose)
h["authors"] <- get_authors(add_html = TRUE)
}
#### Return ####
if(isTRUE(as_list)){
return(h)
} else {
#### Add a break after the first item (usually hex sticker) ####
if(!is.null(h[["hex"]])){
hc <- paste(paste0(h[1],"<br><br>"),
paste(h[-1],collapse=sep),
sep=sep)
} else {
hc <- paste(h,collapse=sep)
}
cat(hc)
return(hc)
}
}
h$hex
is.null(h$hex)
h[names(h)!="hex"]
h[1]
library(rworkflows)
rworkflows::use_workflow(name = "rworkflows_static")
rworkflows::use_workflow(name = "rworkflows_static", force_new = T)
library(rworkflows)
rworkflows::use_workflow(name = "rworkflows_static", force_new = T)
rworkflows::use_workflow(name = "rworkflows_static", force_new = T)
rworkflows::use_workflow(name = "rworkflows_static", force_new = T)
library(rworkflows)
rworkflows::use_workflow(name = "rworkflows_static", force_new = T)
library(rworkflows)
?covr::codecov()
covr::codecov()
